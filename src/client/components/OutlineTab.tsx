import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useParams, useNavigate, useSearchParams } from 'react-router-dom';
import { Button, Typography, Spin, Alert, Card, Divider, Input, InputNumber, Form, Space, notification } from 'antd';
import { ArrowLeftOutlined, SendOutlined, FileTextOutlined } from '@ant-design/icons';
import StoryInspirationEditor from './StoryInspirationEditor';

const { Title, Text, Paragraph } = Typography;

interface OutlineData {
    title: string;
    genre: string;
    sellingPoints: string;
    setting: string;
    synopsis: string;
    characters: Array<{ name: string; description: string }>;
}

interface OutlineSessionData {
    sessionId: string;
    ideationSessionId: string;
    status: 'active' | 'completed';
    userInput?: string;
    outline?: OutlineData;
    createdAt: string;
}

const OutlineTab: React.FC = () => {
    const { id: outlineId } = useParams<{ id: string }>();
    const [searchParams] = useSearchParams();
    const navigate = useNavigate();

    // URL parameters
    const artifactId = searchParams.get('artifact_id');

    // State management
    const [currentUserInput, setCurrentUserInput] = useState('');
    const [currentArtifactId, setCurrentArtifactId] = useState<string | null>(artifactId);
    const [isLoading, setIsLoading] = useState(false);
    const [isLoadingSession, setIsLoadingSession] = useState(false);
    const [error, setError] = useState<Error | null>(null);
    const [outlineSession, setOutlineSession] = useState<OutlineSessionData | null>(null);
    // New state for streaming
    const [streamingOutlineData, setStreamingOutlineData] = useState<Partial<OutlineData> | null>(null);
    const [outlineSessionIdFromStream, setOutlineSessionIdFromStream] = useState<string | null>(null);
    const eventSourceRef = useRef<EventSource | null>(null);

    // New state for outline generation options
    const [totalEpisodes, setTotalEpisodes] = useState<number | null>(50);
    const [episodeDuration, setEpisodeDuration] = useState<number | null>(2);

    // Determine if we're in creation mode or viewing mode
    const isCreationMode = !outlineId && artifactId;
    const isViewingMode = !!outlineId;

    // Load existing outline session if in viewing mode
    useEffect(() => {
        if (isViewingMode && outlineId) {
            loadOutlineSession(outlineId);
        }
    }, [outlineId, isViewingMode]);

    // Auto-generate outline when first navigating to creation mode with artifact_id
    /* REMOVED Auto-generation useEffect
    useEffect(() => {
        if (isCreationMode && currentArtifactId && !hasAutoGenerated && !isLoading) {
            console.log('Auto-generating outline for artifact:', currentArtifactId);
            setHasAutoGenerated(true);
            handleGenerateOutline();
        }
    }, [isCreationMode, currentArtifactId, hasAutoGenerated, isLoading]);
    */

    const loadOutlineSession = async (sessionId: string) => {
        setIsLoadingSession(true);
        setError(null);

        try {
            const response = await fetch(`/api/outlines/${sessionId}`);

            if (!response.ok) {
                throw new Error(`Failed to load outline session: ${response.status}`);
            }

            const data = await response.json();
            setOutlineSession(data);
            setCurrentUserInput(data.userInput || '');

        } catch (err) {
            console.error('Error loading outline session:', err);
            setError(err instanceof Error ? err : new Error(String(err)));
        } finally {
            setIsLoadingSession(false);
        }
    };

    const handleStoryInspirationValueChange = useCallback((value: string) => {
        setCurrentUserInput(value);
    }, []);

    const handleArtifactChange = useCallback((newArtifactId: string | null) => {
        console.log('OutlineTab: Artifact ID changed from', currentArtifactId, 'to', newArtifactId);
        setCurrentArtifactId(newArtifactId);
        setStreamingOutlineData(null); // Clear previous streaming data when artifact changes
        setOutlineSessionIdFromStream(null); // Clear previous stream session ID
        if (eventSourceRef.current) { // Close any active stream
            eventSourceRef.current.close();
            eventSourceRef.current = null;
        }

        // Update URL with new artifact ID, but use replace: true to avoid navigation disruption
        if (newArtifactId) {
            const newSearchParams = new URLSearchParams();
            newSearchParams.set('artifact_id', newArtifactId);
            // Use replace: true and don't trigger a full navigation to preserve focus
            window.history.replaceState(null, '', `/new-outline?${newSearchParams.toString()}`);
        } else {
            // Clear artifact_id from URL if null
            window.history.replaceState(null, '', '/new-outline');
        }
    }, [currentArtifactId]);

    const handleGenerateOutline = async () => {
        if (!currentArtifactId) {
            console.warn('handleGenerateOutline: No currentArtifactId, cannot generate.');
            notification.error({ message: 'é”™è¯¯', description: 'æ²¡æœ‰æœ‰æ•ˆçš„æºçµæ„ŸIDï¼Œæ— æ³•ç”Ÿæˆå¤§çº²ã€‚' });
            return;
        }

        console.log('handleGenerateOutline: Initiating outline generation for artifactId:', currentArtifactId, 'with totalEpisodes:', totalEpisodes, 'episodeDuration:', episodeDuration);

        setIsLoading(true);
        setError(null);
        setStreamingOutlineData(null); // Clear previous stream data
        setOutlineSessionIdFromStream(null); // Clear previous stream session ID

        // Close any existing EventSource connection
        if (eventSourceRef.current) {
            eventSourceRef.current.close();
        }

        const apiUrl = `/api/outlines/from-artifact/${currentArtifactId}`;
        const eventSource = new EventSource(apiUrl, { withCredentials: true });
        eventSourceRef.current = eventSource;

        eventSource.onopen = () => {
            console.log('SSE connection opened for outline generation.');
            notification.info({ message: 'è¿æ¥æˆåŠŸ', description: 'æ­£åœ¨ç”Ÿæˆå¤§çº²ï¼Œè¯·ç¨å€™...' });
        };

        eventSource.addEventListener('metadata', (event) => {
            console.log('SSE metadata event:', event.data);
            try {
                const meta = JSON.parse(event.data);
                if (meta.outlineSessionId) {
                    setOutlineSessionIdFromStream(meta.outlineSessionId);
                    console.log('Received outlineSessionId from stream:', meta.outlineSessionId);
                }
            } catch (e) {
                console.error('Failed to parse SSE metadata:', e);
            }
        });

        eventSource.onmessage = (event) => {
            // This is the default event for data chunks
            console.log('SSE data event:', event.data);
            try {
                const incomingData = JSON.parse(event.data) as Partial<OutlineData>;
                setStreamingOutlineData(prevData => ({
                    ...(prevData || {}),
                    ...incomingData
                }));
                if (isLoading) setIsLoading(false); // Stop global loading once first data arrives, rely on component for progressive view
            } catch (e) {
                console.error('Failed to parse SSE JSON data:', e);
                setError(new Error('æ— æ³•è§£æå®æ—¶æ•°æ®æµä¸­çš„å†…å®¹ã€‚'));
                // Don't close stream here, might get more data or error event
            }
        };

        eventSource.addEventListener('stream_end', (event) => {
            console.log('SSE stream_end event:', event.data);
            notification.success({ message: 'æˆåŠŸ', description: 'å¤§çº²ç”Ÿæˆå®Œæˆï¼' });
            setIsLoading(false);
            if (eventSourceRef.current) {
                eventSourceRef.current.close();
                eventSourceRef.current = null;
            }
            // Navigate after stream ends and we have the session ID
            if (outlineSessionIdFromStream) {
                navigate(`/outlines/${outlineSessionIdFromStream}`);
            } else {
                console.warn('Stream ended but outlineSessionIdFromStream is not set. Cannot navigate.');
                setError(new Error('å¤§çº²å·²ç”Ÿæˆï¼Œä½†æ— æ³•è·å–ä¼šè¯IDè¿›è¡Œè·³è½¬ã€‚'));
            }
        });

        const handleErrorEvent = (eventName: string, eventData: string) => {
            console.error(`SSE ${eventName} event:`, eventData);
            let errorDetails = { message: 'æœªçŸ¥æµé”™è¯¯' };
            try {
                errorDetails = JSON.parse(eventData);
            } catch (e) { /* ignore parse error */ }
            setError(new Error(`å¤§çº²ç”Ÿæˆæµé”™è¯¯: ${errorDetails.message}`));
            notification.error({ message: 'æµé”™è¯¯', description: `å¤§çº²ç”Ÿæˆè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${errorDetails.message}` });
            setIsLoading(false);
            if (eventSourceRef.current) {
                eventSourceRef.current.close();
                eventSourceRef.current = null;
            }
        };

        eventSource.addEventListener('stream_error', (event) => handleErrorEvent('stream_error', event.data));
        eventSource.addEventListener('processing_error', (event) => handleErrorEvent('processing_error', event.data));
        eventSource.addEventListener('critical_error', (event) => handleErrorEvent('critical_error', event.data));

        eventSource.onerror = (err) => {
            console.error('SSE Error:', err);
            setError(new Error('å¤§çº²ç”Ÿæˆè¿æ¥å¤±è´¥æˆ–ä¸­æ–­ã€‚'));
            notification.error({ message: 'è¿æ¥é”™è¯¯', description: 'ä¸æœåŠ¡å™¨çš„è¿æ¥ä¸­æ–­ï¼Œè¯·é‡è¯•ã€‚' });
            setIsLoading(false);
            if (eventSourceRef.current) {
                eventSourceRef.current.close();
                eventSourceRef.current = null;
            }
        };
    };

    const handleBackToIdeation = () => {
        if (isCreationMode && currentArtifactId) {
            // Navigate back to ideation with artifact ID
            navigate(`/ideation?artifact_id=${currentArtifactId}`);
        } else if (isViewingMode && outlineSession) {
            navigate(`/ideation/${outlineSession.ideationSessionId}`);
        } else {
            navigate('/ideations');
        }
    };

    const renderOutlineComponents = () => {
        const dataToRender = streamingOutlineData || outlineSession?.outline;

        if (!dataToRender && isLoading) { // Show spinner if loading and no data yet
            return <div style={{ textAlign: 'center', margin: '50px' }}><Spin size="large" tip="æ­£åœ¨åŠ è½½å¤§çº²ç»“æ„..." /></div>;
        }

        if (!dataToRender) {
            // If not loading and no data (e.g. before generation or if viewing an empty session)
            return isCreationMode ?
                <Alert message="è¯·é…ç½®é€‰é¡¹å¹¶ç‚¹å‡»ç”Ÿæˆå¤§çº²" type="info" showIcon /> :
                <Alert message="æœªæ‰¾åˆ°å¤§çº²æ•°æ®" type="warning" showIcon />;
        }

        const {
            title = "æ ‡é¢˜åŠ è½½ä¸­...",
            genre = "ç±»å‹åŠ è½½ä¸­...",
            sellingPoints = "å–ç‚¹åŠ è½½ä¸­...",
            setting = "è®¾å®šåŠ è½½ä¸­...",
            synopsis = "æ¢—æ¦‚åŠ è½½ä¸­...",
            characters = []
        } = dataToRender as Partial<OutlineData>; // Cast to partial to handle incomplete stream

        const baseComponents = [
            { label: 'å‰§å', value: title, icon: 'ğŸ¬', rows: 1 },
            { label: 'é¢˜æç±»å‹', value: genre, icon: 'ğŸ­', rows: 1 },
            { label: 'é¡¹ç›®å–ç‚¹/çˆ½ç‚¹', value: sellingPoints, icon: 'â­', rows: 4 },
            { label: 'æ•…äº‹è®¾å®š', value: setting, icon: 'ğŸŒ', rows: 3 },
            { label: 'æ•…äº‹æ¢—æ¦‚', value: synopsis, icon: 'ğŸ“–', rows: 6 }
        ];

        return (
            <div style={{ marginTop: '24px' }}>
                <Title level={4} style={{ color: '#ffffff', marginBottom: '24px', fontSize: '20px' }}>
                    æ•…äº‹å¤§çº²
                </Title>

                <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                    {baseComponents.map((component, index) => (
                        <Card
                            key={`base-${index}`}
                            size="small"
                            style={{
                                background: '#0f0f0f',
                                border: '1px solid #404040',
                                borderRadius: '8px',
                                padding: '20px'
                            }}
                        >
                            <div style={{ marginBottom: '12px' }}>
                                <Text strong style={{ fontSize: '18px', color: '#ffffff' }}>
                                    {component.icon} {component.label}
                                </Text>
                            </div>
                            <Input.TextArea
                                value={component.value}
                                readOnly
                                rows={component.rows}
                                style={{
                                    backgroundColor: '#1a1a1a',
                                    border: '1px solid #505050',
                                    color: '#e8e8e8',
                                    fontSize: '16px',
                                    lineHeight: '1.7',
                                    resize: 'none',
                                    cursor: 'default',
                                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'
                                }}
                                autoSize={{ minRows: component.rows, maxRows: component.rows + 2 }}
                            />
                        </Card>
                    ))}

                    {characters && characters.length > 0 && (
                        <>
                            <Divider style={{ borderColor: '#404040', margin: '24px 0' }} />
                            <Title level={5} style={{ color: '#ffffff', marginBottom: '16px', fontSize: '18px' }}>
                                ä¸»è¦äººç‰©
                            </Title>
                            {characters.map((character, index) => (
                                <Card
                                    key={`char-${index}`}
                                    size="small"
                                    style={{
                                        background: '#0f0f0f',
                                        border: '1px solid #404040',
                                        borderRadius: '8px',
                                        padding: '20px'
                                    }}
                                >
                                    <div style={{ marginBottom: '12px' }}>
                                        <Text strong style={{ fontSize: '18px', color: '#ffffff' }}>
                                            ğŸ‘¤ {character.name || "è§’è‰²ååŠ è½½ä¸­..."}
                                        </Text>
                                    </div>
                                    <Input.TextArea
                                        value={character.description || "æè¿°åŠ è½½ä¸­..."}
                                        readOnly
                                        rows={3} // Default rows for character description
                                        style={{
                                            backgroundColor: '#1a1a1a',
                                            border: '1px solid #505050',
                                            color: '#e8e8e8',
                                            fontSize: '16px',
                                            lineHeight: '1.7',
                                            resize: 'none',
                                            cursor: 'default',
                                            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'
                                        }}
                                        autoSize={{ minRows: 2, maxRows: 5 }}
                                    />
                                </Card>
                            ))}
                        </>
                    )}
                </div>
            </div>
        );
    };

    // Cleanup EventSource on component unmount
    useEffect(() => {
        return () => {
            if (eventSourceRef.current) {
                console.log('Cleaning up EventSource on OutlineTab unmount.');
                eventSourceRef.current.close();
                eventSourceRef.current = null;
            }
        };
    }, []);

    if (isLoadingSession) {
        return (
            <div style={{ padding: '20px', maxWidth: '800px', width: "100%", margin: '0 auto', overflow: "auto" }}>
                <div style={{ textAlign: 'center', padding: '40px' }}>
                    <Spin size="large" />
                    <div style={{ marginTop: '16px', color: '#d9d9d9' }}>åŠ è½½å¤§çº²ä¸­...</div>
                </div>
            </div>
        );
    }

    return (
        <div style={{ padding: '20px', maxWidth: '800px', width: "100%", margin: '0 auto', overflow: "auto" }}>
            {/* Header */}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    {/* <Button
                        icon={<ArrowLeftOutlined />}
                        onClick={handleBackToIdeation}
                        type="text"
                        style={{ color: '#1890ff' }}
                    >
                        è¿”å›
                    </Button> */}
                    <Title level={4} style={{ margin: 0, color: '#ffffff', fontSize: '20px' }}>
                        {isCreationMode ? 'è®¾è®¡æ•…äº‹å¤§çº²' : 'æ•…äº‹å¤§çº²è¯¦æƒ…'}
                    </Title>
                </div>
            </div>

            <Paragraph style={{ color: '#d0d0d0', marginBottom: '24px', fontSize: '16px', lineHeight: '1.6' }}>
                {isCreationMode
                    ? 'åŸºäºä½ çš„æ•…äº‹çµæ„Ÿï¼ŒAIå°†ç”Ÿæˆå®Œæ•´çš„æ•…äº‹å¤§çº²ï¼ŒåŒ…å«å‰§åã€é¢˜æç±»å‹ã€é¡¹ç›®å–ç‚¹ã€æ•…äº‹è®¾å®šå’Œæ•…äº‹æ¢—æ¦‚ã€‚'
                    : 'è¿™æ˜¯æ ¹æ®æ•…äº‹çµæ„Ÿç”Ÿæˆçš„å®Œæ•´å¤§çº²ï¼ŒåŒ…å«äº†æ•…äº‹çš„æ ¸å¿ƒè¦ç´ ã€‚'
                }
            </Paragraph>

            {/* Story Inspiration Section */}
            {isCreationMode ? (
                <>
                    <StoryInspirationEditor
                        currentArtifactId={currentArtifactId || undefined}
                        onValueChange={handleStoryInspirationValueChange}
                        onArtifactChange={handleArtifactChange}
                        readOnly={isViewingMode}
                        placeholder="ç¼–è¾‘ä½ çš„æ•…äº‹çµæ„Ÿï¼Œç„¶åç”Ÿæˆå¤§çº²"
                    />
                    <Form layout="vertical" style={{ marginTop: '24px', marginBottom: '24px' }}>
                        <Space direction="horizontal" wrap align="start" size="large">
                            <Form.Item
                                label={<Text style={{ fontSize: '16px', color: '#e0e0e0' }}>æ€»é›†æ•°</Text>}
                                style={{ marginBottom: 0 }}
                            >
                                <InputNumber
                                    min={30}
                                    max={150}
                                    value={totalEpisodes}
                                    onChange={setTotalEpisodes}
                                    style={{ width: '120px', backgroundColor: '#1f1f1f', color: '#e0e0e0', borderColor: '#505050' }}
                                />
                                <Text type="secondary" style={{ marginLeft: '8px', color: '#a0a0a0' }}> (30-150é›†)</Text>
                            </Form.Item>
                            <Form.Item
                                label={<Text style={{ fontSize: '16px', color: '#e0e0e0' }}>æ¯é›†æ—¶é•¿ (åˆ†é’Ÿ)</Text>}
                                style={{ marginBottom: 0 }}
                            >
                                <InputNumber
                                    min={1}
                                    max={10}
                                    value={episodeDuration}
                                    onChange={setEpisodeDuration}
                                    style={{ width: '120px', backgroundColor: '#1f1f1f', color: '#e0e0e0', borderColor: '#505050' }}
                                />
                                <Text type="secondary" style={{ marginLeft: '8px', color: '#a0a0a0' }}>(1-10åˆ†é’Ÿ)</Text>
                            </Form.Item>
                        </Space>
                    </Form>
                </>
            ) : (
                <div style={{ marginBottom: '24px' }}>
                    <Text strong style={{ display: 'block', marginBottom: '12px', fontSize: '18px', color: '#ffffff' }}>
                        æ•…äº‹çµæ„Ÿ
                    </Text>
                    <div style={{
                        padding: '20px',
                        background: '#0f0f0f',
                        border: '1px solid #505050',
                        borderRadius: '8px',
                        color: '#e8e8e8',
                        fontSize: '16px',
                        lineHeight: '1.7',
                        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'
                    }}>
                        {outlineSession?.userInput || 'æ— æ•…äº‹çµæ„Ÿæ•°æ®'}
                    </div>
                </div>
            )}

            {/* Generate Button (Creation Mode Only) */}
            {isCreationMode && currentUserInput.trim() && currentArtifactId && (
                <Button
                    type="primary"
                    icon={<FileTextOutlined />}
                    onClick={handleGenerateOutline}
                    loading={isLoading}
                    size="large"
                    style={{
                        marginBottom: '24px',
                        height: '44px',
                        fontSize: '16px',
                        fontWeight: '500',
                        background: '#52c41a',
                        borderColor: '#52c41a'
                    }}
                >
                    {isLoading ? 'ç”Ÿæˆå¤§çº²ä¸­...' : 'ç”Ÿæˆæ•…äº‹å¤§çº²'}
                </Button>
            )}

            {/* Error Display */}
            {error && (
                <Alert
                    message="ç”Ÿæˆå¤±è´¥"
                    description={error.message}
                    type="error"
                    showIcon
                    style={{ marginBottom: '16px' }}
                />
            )}

            {/* Loading State */}
            {isLoading && (
                <div style={{
                    textAlign: 'center',
                    padding: '40px',
                    border: '1px solid #303030',
                    borderRadius: '8px',
                    backgroundColor: '#141414'
                }}>
                    <Spin size="large" />
                    <div style={{ marginTop: '16px', color: '#d9d9d9' }}>
                        AIæ­£åœ¨åˆ†æä½ çš„æ•…äº‹çµæ„Ÿï¼Œç”Ÿæˆè¯¦ç»†å¤§çº²...
                    </div>
                </div>
            )}

            {/* Outline Components (Viewing Mode) */}
            {isViewingMode && outlineSession && renderOutlineComponents()}

            {/* Status Info */}
            {isViewingMode && outlineSession && (
                <div style={{ marginTop: '32px', padding: '20px', background: '#0f0f0f', borderRadius: '8px', border: '1px solid #505050' }}>
                    <Text type="secondary" style={{ fontSize: '14px', color: '#c0c0c0' }}>
                        å¤§çº²çŠ¶æ€: {outlineSession.status === 'completed' ? 'å·²å®Œæˆ' : 'è¿›è¡Œä¸­'} |
                        åˆ›å»ºæ—¶é—´: {new Date(outlineSession.createdAt).toLocaleString('zh-CN')}
                    </Text>
                </div>
            )}
        </div>
    );
};

export default OutlineTab; 